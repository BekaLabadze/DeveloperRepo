//
//  NotDependencyInversionViewController.swift
//  SOLID
//
//  Created by Beka on 13.11.24.
//

// Dependency Inversion პრინციპის გათვალისწინებით ჩვენი კოდის უნდა იყოს ისე სტრუტურიზებული, რომ ისეთი მოდულები/კლასები/ფუნქციონალი, რომელიც პასუხისმგებელია უფრო დიდ და მაშტაბურ საქმეზე და უფრო დიდი სურათის დახატვაზე არ უნდა იყვნენ დამოკიდებულები, კოდის ბლოკების/მოდულების იმ ნაწილზე, რომლებიც ასრულებენ უფრო მცირე ნაწილს და მათი მოდიფიკაციის შემთხვევაში არ მოხდება მთავარი და ზოგადი ფუნქციონალის არევა. ქვევით მოყვანილი მაგალითიდან გამომდინარე გვაქვს მართვის პულტი, რომელიც უშუალოდ დამოკიდებულია ტელევიზორზე და მის გამოყენებას სხვა ტექნიკისტის, მაგალითად კონდიციონერის ჩასართავად ჩვენ მოგვიწევდა უშუალოდ Switch კლასსში ცვლილებების შეტანა.

class TV {
    func turnOn() {
        print("TV is ON")
    }

    func turnOff() {
        print("TV is OFF")
    }
}

class Switch {
    var television = TV()

    func pressSwitch() {
        television.turnOn()
    }
}
